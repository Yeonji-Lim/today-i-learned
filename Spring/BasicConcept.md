# Spring

## 프레임워크

## 오픈 소스

## IoC 컨테이너를 가진다.

Inversion of Control : 제어의 역전 -> 주도권을 스프링이 갖는다.

~~~
**
Class    : 설계도 (추상적인 것)    -> 가구
Object   : 실체화가 가능한 것      -> 의자
Instance : 실체화가 된 것         -> 의자1, 의자2
~~~

생성된 object(instance)는 heap 메모리에 올라가게 된다.

그리고 그걸 생성한 메서드가 관리하게 된다.


그래서 다른 메서드에서 같은 오브젝트를 사용하고 싶다면 공유 받아야함

스프링은 오브젝트 목록을 읽어서(스캔) heap 메모리에 알아서 띄워주고 관리함 -> IoC

모든 클래스의 메소드에서 같은 오브젝트를 공유해서 사용할 수 있음 (싱글톤)


## DI를 지원한다.


Dependency Injection : 의존성 주입

모든 클래스의 메소드에서 같은 오브젝트를 공유해서 사용할 수 있음 -> DI


## 많은 필터를 가지고 있다.


필터 : 검열의 역할, 문지기


스프링에는 많은 필터가 있는데 사용할 수도 있고, 사용안되고 있던 걸 사용할 수도 있고, 직접 필터를 생성할 수도 있음


실제로는 톰캣 안에 스프링 컨테이너가 있고 톰캣의 필터(web.xml)를 거치고 스프링 컨테이너의 필터(인터셉터, AOP)를 거치는 방식임


## 많은 어노테이션을 가지고 있다. 리플렉션, 컴파일 체킹


어노테이션은 주석인데 컴파일러가 이걸 무시하지 않고 이걸 통해 뭔가를 체크함

힌트의 역할

오버라이드라고 적어서 컴파일러가 그걸보고 직접 확인할 수 있음


스프링에서는 어노테이션을 객체 생성에 쓴다.


런타임에서 클래스를 분석함 -> 리플렉션
   
메소드, 필드, 어노테이션을 보고 미리 설정한 행동을 함


리플렉션 : 런타임 시 해당 클래스가 어떤 것들을 들고 있는지를 분석함

## Message Converter를 가지고 있다. 기본값은 json


중간언어 : 주로 xml을 썼었는데 이제 주로 json을 쓰고 있음


ex : 자바 프로그램 <-> json <-> 파이썬 프로그램

이때 번역해주는게 Message Converter


8 bit = 1 byte : 통신의 단위, 하나의 문자


## BufferedReader와 BufferedWriter를 쉽게 사용할 수 있다.


원래 배열로 입력 받음

-> 배열은 크기가 고정적임


BufferedReader는 가변적으로 입력을 받을 수 있다.


@ResponseBody -> BufferedWriter

@RequestBody -> BufferedReader


## 계속 발전중이다.

# JPA

## Java Persistence API

Persistence : 영속성, 데이터를 생성한 프로그램의 실행이 종료되더라도 사라지지 않는 데이터의 특성

RAM이 아니라 하드디스크에 저장되는 것이랑 비슷한 느낌

JAVA에 있는 데이터를 영구히 기록할 수 있는 환경을 제공하는 API

### API? 

Application Programming Interface

프로그램을 만들기 위해서 제공되는 인터페이스

### 인터페이스?

상하관계가 존재하는 약속

✻ 프로토콜은 동등한 관계에서 하는 약속


## JPA는 ORM 기술이다.

Object Relational Mapping

마치 하인 같은 것


모델링 한다는 것 : 추상적인 개념을 현실세계로 뽑아낸다는 것

TRM : 테이블에 있는 데이터를 현재 언어의 타입에 매핑해야 함 -> 모델링


ORM은 오브젝트를 통해서 데이터를 생성하는 것임 : 모델링의 반대

이 과정을 위해서 필요한 것은 JPA가 가지고 있는 인터페이스


자바에서 어떤 클래스를 만들어서 실행을 하면 데이터의 테이블이 자동으로 생성되게 하는 기법을 ORM이라고 함


## JPA는 반복적인 CRUD작업을 생략하게 해준다.

원래는 이 작업을 위해서 자바가 DB에게 커넥션을 요청함 그러면 DB는 필요한 세션을 열어줌

그렇게 되면 연결이 되고 자바는 커넥션을 가지게 된다.

자바는 그러면 쿼리를 전송할 수 있다 데이터 베이스는 해당하는 처리를 해주고 자바에 응답을 하게 됨

자바는 이걸 받아서 데이터 베이스의 데이터 타입을 자바 오브젝트로 변경해야 한다.


위와 같은 일을 원래는 반복적으로 해줘야 하는데,

JPA를 쓰게 되면 이러한 일들을 함수 하나로 제공!

## JPA는 영속성 컨텍스트를 가지고 있다.

영속성 : 어떤 데이터를 영구적으로 저장


자바에서는 데이터를 영구적으로 저장할 때 파일 시스템이 아니라 DB를 이용한다.


컨텍스트 : Context, 어떤 대상의 모든 정보

개념이 많이 모호한 편임


영속성 컨텍스트

어떤 데이터를 DB에 저장하려 한다고 하자

그러면 바로 직접적으로 데이터가 DB에 바로 접근하는 것이 아니라 그 중간에 영속성 컨텍스트라는 것이 있다.

프로그램에서 DB에 접근하는 모든 정보를 영속성 컨텍스트가 알고있다.

DB에 저장하기 전에 영속성 컨텍스트 : 자바가 저장하는 모든 데이터를 알고 있다.


그래서 데이터를 저장하고 있으면 프로그램(자바)는 영속성 컨텍스트에 데이터를 던진다.

영속성 컨텍스트는 데이터를 데이터 베이스에 준다. 그렇게 해서 DB에 데이터가 저장된다.


그런데 그리고 나서 영속성 컨텍스트에서 이 데이터를 삭제하면 DB에 있는 해당 데이터가 삭제된다.

즉 영속성 컨텍스트에 있는 데이터와 데이터 베이스에 있는 데이터가 동기화되는 것!


어떤 데이터를 요청할 때 영속성 컨텍스트에 해당하는 데이터가 없다면 영속성 컨텍스트는 DB에서 해당하는 데이터를 가져다가

자바 객체로 변환하여 가지고 있는다. (내용은 같고 타입이 다름)

그리고 나서 영속성 컨텍스트가 자바 객체로 변환된 해당 데이터를 프로그램에게 넘겨준다.

이 상태에서 DB, 영속성 컨텍스트, 프로그램에 있는 그 데이터는 동일하다.


이때 프로그램에서 이 데이터를 변경하면 영속성 컨텍스트의 데이터는 자동으로 변경된다.

이 데이터를 DB에 넣으려고 시도하면 DB에 있는 데이터와 영속성컨텍스트에 있는 데이터가 달라진다.

이때는 insert 가 아니라 update가 자동으로 일어난다.

이런 일을 해주는 것이 영속성 컨텍스트.


자바가 DB에 대해 해야하는 모든 메타 데이터들을 영속성 컨텍스트가 가지고 있다.


## JPA는 DB와 OOP의 불일치성을 해결하기 위한 방법론을 제공한다.

DB의 특징 중 하나는 각각의 컬럼들을 가질 수 있는 자료가 기본 자료형이라는 것이다.

오브젝트를 가질 수 없음! 이를 해결하기 위해서 foreign key를 사용한다.


그런데 자바의 입장에서 보자

이 DB의 형태를 그대로 가져간다고 했을 때 foreign key의 값만을 알 수 있다.

구체적으로 어떤 객체를 가지고 있는지 확인하려면, 두번의 select를 하거나 join을 이용해야 한다.


그런데 자바는 기본 자료형이 아닌 오브젝트를 저장할 수 있다.

그렇게 해서 한번에 확인할 수 있다.


그러면 DB와 자바에서의 형태가 다르게 된다.

이때 JPA가 자동으로 자바에서 객체로 표현된 것에 자동으로 데이터를 매핑해준다.

DB에서는 JPA가 자동으로 foreign key를 생성해준다.

## JPA는 OOP의 관점에서 모델링을 할 수 있게 해준다.

상속, 컴포지션, 연관관계가 가능하다.

​
## JPA는 방언(dialect)처리가 용이하여 Migration을 하기 좋다. 

유지보수에도 좋다.

JPA에 연결되는 DB는 여러종류가 가능하다. 추상화객체로 다루기 때문에 이 추상화객체가 어떤 거냐에 상관이 없다.

마치 우리가 종이에 글을 쓸 때와 마찬가지다.

연필로 쓰다가 볼펜으로 쓴다고 글을 쓰지 못하는게 아니고 만년필, 붓, 형광펜 등 어떤 필기도구든지 그 필기도구를 이용해서 글을 쓸 수 있다.

## 웹서버

필요한 데이터를 가지고 있는 것

요청은 웹서버의 위치인 IP주소, 필요한 자원의 위치인 URL을 포함해서 요청함

​
## 톰켓

아파치라는 웹서버를 사용할 때, 자바코드가 포함된 .jsp를 요청하면 아파치는 이해하지 못함

그래서 이걸 해결하기 위해 톰켓을 쓴다. 이런 요청이 들어오면 제어권을 톰켓이 받는다.

그러면 톰켓은 .jsp에 있는 모든 자바코드를 컴파일하고 컴파일이 끝나면 그 데이터를 .html에 덮어씌움

아파치는 이 .html을 응답해주는 것