# 주소 지정 방식
	왜 컴퓨터의 명령어는 연산자, 피연산자로 이루어져있을 때, 피연산자에 실제 데이터를 넣지 않고 데이터의 주소를 넣는가?

-> 이게 주소 지정 방식이고 주소 지정 방식을 하는 이유를 물어보는 것임

[명령어](Instruction)의 길이(n비트)는 정해져있다. 

그리고 피연산자의 개수는 정해져있지 않음
연산자의 길이가 m비트라고 하면, 피연산자의 개수에 따라 각 피연산자의 길이는 (n-m)비트, (n-m)/2 비트, (n-m)/3 비트가 될 수 있음

그런데 [메모리](Memory)에 데이터를 넣고 메모리의 주소를 넣으면 더 넓은 공간(메모리에 들어갈 수 있는 데이터의 크기)만큼 데이터를 표현할 수 있고 저장할 수 있음
[유효주소](Effective_Address)
## 종류
### 즉시 주소 지정 방식 immediate
그런데 즉시 주소 지정 방식의 경우 주소가 아니라 데이터가 오퍼랜드(피연산자)에 들어있음;
- 표현할 수 있는 데이터 크기가 작아짐
- 메모리나 레지스터로부터 데이터를 찾는 과정이 없음 -> 빨라버림

### 직접 주소 지정 방식 direct
유효 주소가 피연산자에 들어있음
그런데 이 경우 피연산자의 길이 만큼만 유효 주소를 표현할 수 있음

### 간접 주소 지정 방식 indirect
유효 주소의 주소를 피연산자에 저장함
유효 주소는 메모리에 저장되어있음
- 메모리에서 두번 찾아야 해서 느림

### [레지스터](Register) 주소 지정 방식 register
데이터를 가지고 잇는 레지스터의 주소를 피연산자에 넣는다.
- CPU 외부에 있는 메모리가 아닌 CPU 내부에 있는 레지스터에 접근하는 것 -> 직접보다 빠름
- 주소 표현 범위에 대한 한계 존재 

### 레지스터 간접 주소 지정 방식 register indirect
간접이랑 비슷한데, 메모리를 한번만 찾음
피연산자에는 레지스터의 주소를 저장, 레지스터에는 메모리의 유효주소가 저장되어 있음

### 스택 주소 지정 방식
스택과 [스택 포인터](Stack_Pointer)를 이용

### 변위 주소 지정 방식 displacement

피연산자 값이랑 어떤 레지스터 값을 더해서 유효 주소 값을 얻어냄
따라서 이때 명령어의 형태는 다른 방식과 다르게, 연산코드, 레지스터, 오퍼랜드 로 구성
레지스터 필드에는 어떤 레지스터의 값과 더할지를 나타냄

어떤 레지스터를 더하는 지에 종류가 달라짐
### 상대주소 지정 방식 relative
[PC](Program_Counter) 기준

### 베이스 레지스터 주소 지정방식
[베이스 레지스터](Base_Register) 기준