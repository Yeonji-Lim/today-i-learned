## 연결리스트가 유리한 경우

에디터와 같이 탐색보다 중간 삽입과 삭제가 빈번한 경우에 유리
삽입과 삭제가 O(1), 탐색이 O(N)

	N이 5000정도로 나온다면 그냥 벡터로 구현해도 되지만 그 이상으로 커지면 연결리스트가 낫다.

## 연결리스트 구현 방식

- STL list -> 이중 연결 리스트
   STL의 list에서는 더미노드가 end()위치에 있다는 것을 주의하자

- 구조체 사용
  
  ```c++
  struct NODE {
	  struct NODE *prev *next;
	  int data;
  };
  ```
  
- 야매 연결 리스트

  ```c++
  const int MX = 1000005;
  int dat[MX], pre[MX], nxt[MX];
  int unused = 1; // 현재 사용되지 않는 인덱스 == 새로운 원소가 들어갈 수 있는 인덱스
  
  fill(pre, pre+MX, -1);
  fill(nxt, nxt+MX, -1);
  ```

  - 이전, 다음 원소의 인덱스를 저장한다. (메모리 누수의 문제 때문에 실무에서는 쓸 수 없는 방식)
  - 구현 난이도가 일반적인 연결리스트보다 낮고, 시간 복잡도가 동일함
  - dat\[0\] 은 연결리스트의 시작원소 -> dummy node : 삽입/삭제 시 원소가 아예 없는 경우에 대한 예외 처리가 번거롭지 않아짐
  - 원소들은 unused 인덱스 전까지 아무렇게나 들어가 있음
  - STL list보다 cache hit rate가 높을 것임

## iterator
iterator를 옮길때는 begin, end조건을 꼭 확인해줘야 한다!

erase하거나 insert하면 iter의 위치가 계속 바뀌어진다. - `BOJ 1406`
iter가 현재 어디인지 모른다면 연산에 들어가기 전에 일단 begin과 같은 확실한 위치로 설정해두고 시작

## Cursor
STL을 사용해서 구현하고자 할 때 커서도 구현해야 한다면 list.end()가 리스트보다 크게 설정된다는 것을 이용해 
실제로는 사이에 있는 커서를 그 바로 뒤에 있는 원소를 가리키는 iter로 표현

## Iterator With Insert
insert를 하면 iterator가 가리키는 곳의 왼쪽에 값을 추가한다.

참고 - `BOJ 5397`

## Iterator With Erase
erase를 하면 iterator가 가리키는 곳이 없어져서 ++, --로 iter를 움직일 수 없다.

- iterator를 이용해서 List.erase()를 하고 나면 그 위치는 없는 위치가 되어 iterator가 엉뚱한 위치를 가리키게 되는 문제가 있다. 

다음과 같이 해결한다.
```c++
   iterator = List.erase(iterator);
```

`erase`는 그 원소의 뒤를 가리키는 iterator를 반환한다.

- iterator가 List.end()를 가리키고 있는 경우에 삭제가 안된다.
- begin()을 삭제하면 안된다. 

## 손코딩 문제

### 1. 원형 연결 리스트 내의 임의의 노드가 하나 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법?

동일한 노드가 나올 때 까지 다음 노드 이동
공간 : O(1)
시간 : O(N)

### 2. 중간에 만나는 두 연결리스트의 시작점들이 주어졌을 때 만나는 지점을 구하는 방법?

내 답 : 먼저 각각 끝에 커서를 위치시키고 서로 다른 노드가 나올 때까 전 노드로 이동
-> 이거는 이중 연결리스트일 때만 가능

정답 : 
두 시작점 각각에 대해 끝까지 진행시켜서 각각의 길이를 구함
다시 두 시작점으로 돌아와서 더 긴쪽을 둘의 차이만큼 앞으로 이동 
두 시작점이 만날 때까지 두 시작점을 동시에 한 칸씩 전진시키면 됨
공간 : O(1)
시간 : O(A+B)

### 3. 주어진 연결리스트안에 사이클이 있는지 판단하라

[Floyd's cycle-finding algorithm](Floyd_Cycle-finding.md)
공간 : O(1)
시간 : O(N)
