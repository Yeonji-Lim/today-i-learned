### 연결리스트가 유리한 경우

에디터와 같이 탐색보다 중간 삽입과 삭제가 빈번한 경우에 유리
삽입과 삭제가 O(1), 탐색이 O(N)

	N이 5000정도로 나온다면 그냥 벡터로 구현해도 되지만 그 이상으로 커지면 연결리스트가 낫다.

### 연결리스트 구현 방식

- STL list -> 이중 연결 리스트
   STL의 list에서는 더미노드가 end()위치에 있다는 것을 주의하자

- 구조체 사용
  
  ```c++
  struct NODE {
	  struct NODE *prev *next;
	  int data;
  };
  ```
  
- 야매 연결 리스트

  ```c++
  const int MX = 1000005;
  int dat[MX], pre[MX], nxt[MX];
  int unused = 1; // 현재 사용되지 않는 인덱스 == 새로운 원소가 들어갈 수 있는 인덱스
  
  fill(pre, pre+MX, -1);
  fill(nxt, nxt+MX, -1);
  ```

  - 이전, 다음 원소의 인덱스를 저장한다. (메모리 누수의 문제 때문에 실무에서는 쓸 수 없는 방식)
  - 구현 난이도가 일반적인 연결리스트보다 낮고, 시간 복잡도가 동일함
  - dat\[0\] 은 연결리스트의 시작원소 -> dummy node : 삽입/삭제 시 원소가 아예 없는 경우에 대한 예외 처리가 번거롭지 않아짐
  - 원소들은 unused 인덱스 전까지 아무렇게나 들어가 있음

## iter
erase하거나 insert하면 iter의 위치가 계속 바뀌어진다. - `BOJ 1406`
iter가 현재 어디인지 모른다면 연산에 들어가기 전에 일단 begin과 같은 확실한 위치로 설정해두고 시작

## With Cursor
STL을 사용해서 구현하고자 할 때 커서도 구현해야 한다면 list.end()가 리스트보다 크게 설정된다는 것을 이용해 
실제로는 사이에 있는 커서를 그 바로 뒤에 있는 원소를 가리키는 iter로 표현

## Iterator With Erase
erase를 하면 iterator가 가리키는 곳이 없어져서 ++, --로 iter를 움직일 수 없다.
