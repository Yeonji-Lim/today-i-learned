> "모든 알고리즘 문제는 동적계획법으로 풀린다."

# 동적계획법 Dynamic Programming

여러 개의 하위 문제를 먼저 푼 후에 그 결과를 쌓아올려서 주어진 문제를 해결하는 알고리즘

점화식을 찾아서 점화식 항을 밑에서부터 차례 구해나가서 답을 알아낸다.

문제의 전체를 해결할 수 있는 실마리를 찾는 것

이와 반대의 개념은 `에드혹` : 그때 그때 맞는 알고리즘으로 푼다. 

## 푸는 과정
1. 테이블을 정의한다.
   
2. 점화식 찾는다.
   
3. 초기값 정한다.

## 어떤 유형의 문제를 푸는가?
1. 큰 문제를 작은 문제로 나눌 수 있음

2. 작은 문제의 답을 큰 문제에서도 동일 -> 작은 문제를 다시 계산해도 같은 값 -> 동일한 함수가 반복 호출됨

`분할정복과의 차이 : DP에서는 문제들이 서로 영향을 미치고 있음`

### 문제 예시 
> 아래 문제와 비슷한 문제를 발견하면 DP를 생각하자.

`W`kg을 넣을 수 있는 배낭에 `N`가지의 보석을 넣는다. 
보석 가치의 합의 최대와 어떤 보석을 얼마나 가져가야 하는가?

가치의 합 뿐만 아니라 보석의 정보도 알기 위해서는 저장소가 하나 더 필요하다
-> 이부분은 추후 다른 문서로 정리 #작성필요 

## 방식

### 1. 메모이제이션 Memoization(캐싱Cashing)
- 탑다운 방식
  
- 재귀함수 사용 -> 이에 따라 `stack overflow`가 발생될 수 있다.
	  함수와, 함수에 들어가야 하는 변수들이 다 스택으로 들어가기 때문!
	  
- 큰 문제 -> 작은 문제

### 2. 타뷸레이션 Tabulation
- 보텀업 방식
  
- 반복문
  
- 작은 문제 -> 큰 문제

`보통 보텀업 방식으로 푸는 것이 좋다.`

## 장단점
### 장점
- 빠른 속도로 최적의 해를 구할 수 있다.
- 필요한 모든 가능성을 고려하여 최적의 결과를 얻을 수 있다.

### 단점
- [메모리](Memory)를 많이 요구한다.
- 필요한 모든 가능성에 대한 고려가 불충분한 경우 최적의 결과를 보장할 수 없다.

## 대표 문제
### BOJ
- 2098

## 참고 

수열 처럼 연속적이지 않고 모든 작은 문제가 아니라 작은 문제의 일부만 접근한다고 했을 때 사전 자료형을 이용하기도 한다.

### 미리 구해야 편한 경우

테스트 케이스가 있어서 여러번 구해야하는 경우에

매번 새로운 n에 대해서 dp\[n\]을 구하는 것보다,

그냥 전체에 대해 미리 구해두고 바로 그때마다 dp\[n\]을 출력하는 것이 좋다. -> BOJ 9095