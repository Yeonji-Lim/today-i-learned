# Insertion Sort

처음부터 하나씩 원소를 보고 이미 정렬된 원소들 중에서 그 원소가 들어갈 곳에 원소를 삽입

더미를 사용하는 경우가 있다.

현재 보고 있는 원소의 값이 배열 내의 최소값인 경우,

그 값이 A[1] 와 비교에서 멈추지 않고 다시 A[0]과 비교 되려 하므로

이를 막기 위하여 A[0]에는 배열의 최소값보다도 더 작은 값(-∞)을 추가로 저장해 놓고 실제 자료는 A[1:n]에 둔다.


```c++

void InsertionSort(int A[ ], int n) {

/* 입력: A[0:n] , n: 원소의 개수. A[0]: dummy.

출력: A[0:n] : A[0]: dummy, A[1:n]은 정렬된 배열임 */

  

int i, j, Value;

for (i ＝ 2; i ＜＝ n; i＋＋) {

Value ＝ A[i];

j ＝ i;

while (A[j－1] ＞ Value){ //자기보다 앞에있는 값들과 비교

A[j] ＝ A[j－1]; //자기보다 큰 원소들을 뒤로 밂

j--;

}

A[j] ＝ Value; //맞는 자리에 원소 삽입

}

}

```

  

## 시간 복잡도

비교 횟수가 원소들의 원래 순서에 민감하다

이미 정렬되어 있는 경우 한번 앞에서 부터 쭉 탐색만 하면 되기 때문에 n

최선 : O(n)

역순으로 정렬되어 있는 경우 계속해서 맨 앞까지 비교해야 하므로

`2+3+...+n = n(n+1)/2-1`

최악 : O(n^2)

단계 i에서 앞의 원소들과 평균적으로 비교하는 횟수를 생각

i 단계 에서 한 번만 비교할 수도 있고, 2번만 비교할 수도 있고, ... i번 비교할 수도 있다.

그리고 각 확률은 모두 동일하다

~~~

(1+2+3+...+i) / i = (i(i+1)/2)/i = (i+1)/2

~~~

전체 평균 비교 횟수

~~~

(3+4+..+n+1)/2 = ((n+1)(n+2)/2-3)/2

= (n^2+3n-4)/2

~~~

## 제자리성 : O

  

i, j, Value등 상수 크기의 메모리

  

## 안정성 : O

  

인접한 레코드끼리 비교하면서 자기와 같은게 나오면 뒤바뀌지 않는다.

  

## 결점

  

현재 삽입하고자 하는 키가 정렬 후에 도착 할 자리에서 많이 벗어나 있어도

  

한번에 한자리씩만 그 곳에 접근할 수 밖에 없다

  

그래서 이를 개선한 것이 Shell Sort