> 자고 있다가 누가 BFS 구현해보라고 해도 5분 안에 구현할 수 있을 정도로 숙달되어야 함   
> 정석적인 코드를 거의 외우다시피 하자

> 가중치가 없는 최단 경로는 무조건 bfs

# Breadth First Search

너비우선탐색

다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘

가까운 노드부터 탐색한다. 형제 노드를 먼저 탐색하고 나서 자식노드를 탐색한다.

[큐](Queue) 자료구조를 사용하는 것이 정석

방문 처리를 필요로 함

## 동작
1. 시작노드를 큐에 push, 방문처리
2. 큐의 맨 앞 노드의 인접 노드 중에서 방문하지 않은 노드를 모두 큐에 push, 방문처리
3. 큐가 빌 때까지 2번 반복

시간 복잡도 : `O(N)`

모든 칸이 큐에 1번씩 들어간다.

행이 R개, 열이 C개인 경우에 `O(RC)`

꼭 그래프의 문제가 아니라 1차원이나 2차원 배열이 주어졌을 때

이를 그래프의 형태로 생각하여 문제를 수월하게 풀 수도 있다.

## 구현

### 주의해야 하는 것

1. 시작점을 큐에 넣을 때 방문처리해야 함
   
2. 항상 큐에 빼낼 때가 아니라 **큐에 넣을 때 방문처리**해야 함
   
    큐에 빼낼 때 방문처리 하면 같은 칸이 큐에 여러번 들어가게 된다. 
    
    -> 시간 초과나 메모리 초과가 발생할 수 있다.
    
3. 이웃한 원소를 보고자할 때 보드에서 벗어났는지 체크해야 함

## 문제 유형

### Flood Fill 색깔 채우기

[BOJ-1926](https://www.acmicpc.net/problem/1926)

### 거리 측정
[BOJ-2178](https://www.acmicpc.net/problem/2178)

#### 시작점이 여러개
[BOJ-7576](https://www.acmicpc.net/problem/7576)

**큐에 쌓이는 순서는 반드시 거리 순이다.**

#### 시작점이 두 종류
BOJ-4179 -> 정리글 작성해둠

#### 1차원에서의 BFS
BOJ-1697

## 깨달은 것들

### 221019

BFS에서 방문한 것의 체크는 중요하고, 방문한 곳을 다시 방문하지 않는 것이 중요하다

시간 복잡도를 줄일 뿐만 아니라, 루프를 도는 것을 방지한다.

dist를 vis로 취급할 때도 마찬가지

### 221128

공간이 2차원이 아니라 3차원으로 갈 경우에 STL pair 대신 vector를 사용하면 그대로 {}형식으로 push 할 수 있음

### 221207

테스트 케이스가 있는 경우에 q를 계속 비워주거나 선언 자체를 테스트 케이스 시작 부분에서 진행해야 한다.

### 221215

이 다음 말은 틀린 말이다.(221216추가) -> 불이 쫒아오는 상황일때 무조건 불 먼저하고 사람을 나중에로 해서 큐를 두개로 하거나 벡터를 두개로 하는 것은 메모리 초과를 초래할 수 있다.

### 221216

불을 먼저하고 사람을 나중에로 해서 큐를 두개하고 벡터를 두개한다고 무조건 메모리초과가 나는 것이 아니다.

위 상황은 5427 불 문제에서 발생했는데, 
사람이 이동할 때 이미 지나간 곳인지 아닌지를 체크하지 않아서 생긴 문제다.
내 생각에는 이미 지나간 곳이라도 다시 감으로 인해서 나갈 수 있으면 된다고 생각했는데,
이렇게 하는 순간 이미 간곳을 엄청 많이 밟을 수 있어서 큐가 감당할 수 없을 만큼 들어갈 수 있다.

> 항상 BFS는 이미 지나간 곳을 제외하여야 한다. 