### 연결리스트가 유리한 경우

에디터와 같이 탐색보다 중간 삽입과 삭제가 빈번한 경우에 유리
삽입과 삭제가 O(1), 탐색이 O(N)

	N이 5000정도로 나온다면 그냥 벡터로 구현해도 되지만 그 이상으로 커지면 연결리스트가 낫다.

### 연결리스트 구현 방식

- STL list -> 이중 연결 리스트

- 구조체 사용
  
  ```c++
  struct NODE {
	  struct NODE *prev *next;
	  int data;
  };
  ```
  
- 야매 연결 리스트

  ```c++
  const int MX = 1000005;
  int dat[MX], pre[MX], nxt[MX];
  int unused = 1; // 현재 사용되지 않는 인덱스 == 새로운 원소가 들어갈 수 있는 인덱스
  
  fill(pre, pre+MX, -1);
  fill(nxt, nxt+MX, -1);
  ```

  - 이전, 다음 원소의 인덱스를 저장한다. (메모리 누수의 문제 때문에 실무에서는 쓸 수 없는 방식)
  - 구현 난이도가 일반적인 연결리스트보다 낮고, 시간 복잡도가 동일함
  - dat\[0\] 은 연결리스트의 시작원소 -> dummy node : 삽입/삭제 시 원소가 아예 없는 경우에 대한 예외 처리가 번거롭지 않아짐
  - 원소들은 unused 인덱스 전까지 아무렇게나 들어가 있음
  