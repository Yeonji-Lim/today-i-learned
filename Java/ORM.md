# Object Relational Mapping

마치 하인 같은 것, 오브젝트 & [관계형 데이터베이스](RDB) 간의 매핑, 즉 두 대상간 매개 역할을 담당한다.

[JPA](JPA)가 Java Application과 [JDBC](JDBC) API 사이에 위치하는 것도 이러한 매개, 중간자 역할에서 비롯된 것

>모델링 한다는 것 : 추상적인 개념을 현실세계로 뽑아낸다는 것
>TRM : 테이블에 있는 데이터를 현재 언어의 타입에 매핑해야 함 -> 모델링

ORM은 오브젝트를 통해서 데이터를 생성하는 것임 : 모델링의 반대

이 과정을 위해서 필요한 것은 [JPA](JPA)가 가지고 있는 인터페이스

자바에서 **어떤 클래스를 만들어서 실행을 하면 데이터의 테이블이 자동으로 생성되게 하는 기법**을 ORM이라고 함

## ORM 기술 이전의 상황
객체가 [영속성](Persistence)을 가지기 위해서 별도의 저장공간인 데이터 베이스 등에 저장을 해야한다.

[데이터 베이스](DataBase)는 객체 구조와 다른 데이터 중심의 구조를 가짐 -> 객체를 데이터 베이스에 직접 저장하거나 조회할 수 없다. 

그렇기 때문에 개발자가 객체지향 애플리케이션과 데이터 베이스의 중간에서 SQL과 JDBC API를 사용하여 변환 작업(객체 -> 데이터베이스)를 직접 해주어야 한다. 

### 기존 개발 형태 : SQL 의존적 개발

**ex: 회원가입의 상황**

1. Member 객체의 getter()를 통해 접근하여 회원 정보 조회
2. 이 정보를 기반으로 INSERT 쿼리 생성
3. 파라미터에 객체로부터 받아온 정보를 하나씩 매핑
4. 쿼리 실행 요청을 전송

이런 개발의 형태를 `SQL 의존적 개발` 형태라고 한다.

### 기존 기술의 불편함

그런데 이러한 개발 형태로 인해 기존 기술의 불편함이 생겼다.

**ex: 비즈니스 요구사항이 수정되어 객체 필드가 추가된 이후 다시 데이터베이스에 저장하는 상황**

객체 정보를 활용해서 쿼리의 파라미터에 매핑 -> 객체와 쿼리 생성 과정은 아주 강하게 서로 연결되어 있다.

개발자 입장에서 객체의 수정과 쿼리 생성 로직을 모두 고려해서 수정 사항을 처리해야함

SQL에 모든 것을 의존하는 상황에서는 개발자들이 엔티티를 신뢰하고 사용할 수 없다.

DAO를 열어서 어떤 SQL이 실행되고, 어떤 객체들이 함께 조회되는지 일일히 확인해야 한다.

그런데 이렇게 엔티티를 맞게 수정한다고 하더라도 `SQL 위존적 개발` 특성으로 쿼리 생성과정에서 오류가 발생하면 의도한 작업 결과를 만들 수 없다.

### <기존 기술의 불편한 점 정리>
비즈니스 요구사항이 변경되었을 때, 

개발자가 처리할 프로세스가 객체 수정에 그치지 않고 쿼리 생성 로직까지 모두 고려해야 하는 등 작업 프로세스가 여러 계층에 나뉘어 있고, 

이 과정에서 실수로 인한 오류 가능성이 적지 않다. 

