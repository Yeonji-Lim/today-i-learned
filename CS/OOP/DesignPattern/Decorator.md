# 데코레이터 패턴

기본 기능에 추가할 수 있는 기능의 종류가 많은 경우

각 추가 기능을 Decorator 클래스로 정의한 후 필요한 Decorator 객체를 조합함으로써 추가 기능의 조합을 설계

주어진 인자에 따라 동적으로 Decorator 객체를 생성할 수도

<img width="573" alt="image" src="https://user-images.githubusercontent.com/57888020/169943505-3578f806-a201-4988-b271-a6203b2bf5db.png">

## 객체 체인의 생성

<img width="792" alt="image" src="https://user-images.githubusercontent.com/57888020/169939864-5c260c3e-0380-4bfa-ae01-89ece9c8efe7.png">

- 데코레이터 객체에서 시작
- 새로운 기능에 대한 책임 추가
- 오리지널 객체에서 마무리

기본적인 것에 계속 어떤 것이 추가하는 느낌

<img width="149" alt="image" src="https://user-images.githubusercontent.com/57888020/169940110-21c0c70a-3e00-4405-8f23-119c81d7781a.png">

객체 체인의 인스턴스화 -> 클라이언트 객체로부터 독립

## 팩토리 객체

테스팅에 데코레이터 이용, 사전 사후 조건 테스트를 위하여 래핑

## 항상 실행되는 기능에 선행되거나 뒤따르는 옵션 기능의 다양성

송신 객체로 끝나는 선택 가능한 기능의 연결 리스트

장식 객체는 송신 객체와 같은 인터페이스를 가져야 함

## Exception

Exception이 던져질 수 있어서 구현은 별로 좋지 않을 수도 있다.

데코레이터나 클라이언트가 처리해야

## 정리

1. 존재하는 기능에 추가적인 기능을 동적으로 추가
- 객체의 체인 구축
- 체인의 첫번째 객체는 클라이언트에 의해 호출됨

2. 새로운 요구에 영향을 받지 않는다.
- 체인의 생성은 사용으로부터 독립되어 있음
