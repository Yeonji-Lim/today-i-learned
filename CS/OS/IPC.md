[[Process]]

# Inter Process Communication(IPC)

프로세스 간 공간은 완전히 분리되어 있다.
프로세스는 기본적으로는 다른 프로세스의 사용자 영역 공간을 직접 접근할 수 없다.
사용자 모드에서 [커널](Kernel.md) 공간 접근은 불가능하지만, 커널 공간 공유는 가능하다.

그럼에도 통신이 필요하기 때문에 나온 것이 IPC

file 사용 기법 제외하고는 모든 기법이 프로세스의 사용자 영역이 아니라 커널 공간을 활용한다.

## 통신이 필요한 이유
성능을 높이기 위함
어떤 로직을 하나의 프로세스가 아니라 여러 프로세스가 수행하게 하여 빠른 성능을 기대할 수 있다.
이를 위해서는 로직 수행과정에서 필요한 데이터를 서로 공유해야

## IPC 기법

### 1. File 사용
파일을 통해 데이터를 주고 받음
실시간으로 직접 원하는 프로세스에 데이터에 전달 하는 것이 어렵다.

### 2. Pipe
단방향 통신, 부모 프로세스를 자식 프로세스에 일방적으로 통신
fork로 자식 프로세스를 만들고 부모 데이터를 자식에게 보낸다
[[System_Call]]

### 3. Mesage Queue
FIFO

msgget
msgsnd
msgrcv

### 4. 공유 메모리
[[Linux_Memory_Structure]]

리눅스는 프로세스 공간이 완전히 분리되어 있음
모든 프로세스는 커널 공간을 공유 한다.

공유 메모리 기법은 커널 공간에 메모리 공간을 만들고, 해당 공간을 변수처럼 사용한다. 
데이터를 버퍼에 넣어서 처리하는 메시지 큐와 다르게 해당 메모리 주소를 변수처럼 접근해서 사용한다.
공유 메모리 key를 통해 여러 프로세스가 접근 가능

### 5. 시그널
가장 많이 사용하지만, IPC 기법을 위해 존재하는 것은 아니다. IPC로 활용하는 것
커널 혹은 프로세스에서 다른 프로세스에 이벤트가 발생했는지를 알려준다. 
프로세스 관련 코드에 관련 시그널 핸들러를 등록해서 해당 시그널 처리를 실행하는 방식으로 공유 <- 먼소리

작동 매커니즘
1. 시그널 무시
2. 시그널 블록
3. 등록된 시그널 핸들러로 특정 동작 수행
4. 등록된 시그널 핸들러가 없으면 커널에서 기본 동작 수행

주요 시그널은 64개 정도된다.

![](https://i.imgur.com/VcAWlmW.png)

PCB에 해당 프로세스가 블록 또는 처리해야하는 시그널도 관리한다.

pending : 처리 대기중인 시그널
sigpending : 받은 시그널 유무
blocked : 블록된 시그널(비트마스크 형식)
sig : 각 시그널에 대한 동작 처리에 대한 핸들러

### 6. Semaphore


### 7. Socket
마찬가지로 본래의 목적이 IPC 활용은 아님
본래 두개의 다른 컴퓨터 간의 네트워트 기반 통신 기술

네크워크 디바이스를 사용할 수 있는 시스템 콜이기도 함

로컬 컴퓨터 간의 통신을 하는 경우, 계층을 타고 내려가면서 송신을 하고, 아래 계층부터 위로 올라가서 대상 프로세스가 수신한다.